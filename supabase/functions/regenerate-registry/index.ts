import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface RoomData {
  id: string;
  nameEn: string;
  nameVi: string;
  tier: string;
  hasData: boolean;
}

const ROOM_FILE_REGEX = /(free|vip1|vip2|vip3|vip4)\.json$/i;

function filenameToRoomId(filename: string): string {
  const base = filename.replace(/\.json$/i, '');
  return base
    .toLowerCase()
    .replace(/[_\s]+/g, '-')
    .replace(/-(free|vip1|vip2|vip3|vip4)$/i, (match) => match.toLowerCase());
}

function extractNames(content: any, filename: string): { nameEn: string; nameVi: string } | null {
  try {
    let nameEn = content.name || null;
    let nameVi = content.name_vi || null;
    
    if (!nameEn && content.title) {
      nameEn = content.title?.en || content.title;
    }
    if (!nameVi && content.title) {
      nameVi = content.title?.vi || content.title;
    }
    
    if (!nameEn) {
      nameEn = content.nameEn || null;
    }
    if (!nameVi) {
      nameVi = content.nameVi || null;
    }
    
    if (!nameEn) {
      nameEn = filename
        .replace(/\.(json)$/i, '')
        .replace(/[_-](free|vip1|vip2|vip3|vip4)$/i, '')
        .replace(/[_-]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }
    
    nameVi = nameVi || nameEn;
    
    return { nameEn, nameVi };
  } catch (err) {
    console.warn(`Could not parse ${filename}:`, err);
    return null;
  }
}

async function scanRoomFiles() {
  const dataDir = './public/data';
  const manifest: Record<string, string> = {};
  const dataImports: Record<string, RoomData> = {};
  
  try {
    const entries = Deno.readDirSync(dataDir);
    
    for (const entry of entries) {
      if (!entry.isFile || !entry.name.endsWith('.json') || entry.name.startsWith('.')) {
        continue;
      }
      
      if (!ROOM_FILE_REGEX.test(entry.name)) {
        continue;
      }
      
      const filename = entry.name;
      const roomId = filenameToRoomId(filename);
      const filePath = `${dataDir}/${filename}`;
      
      try {
        const content = JSON.parse(await Deno.readTextFile(filePath));
        const names = extractNames(content, filename);
        
        if (!names) {
          console.warn(`Skipping ${filename}: Could not extract names`);
          continue;
        }
        
        let tier = 'free';
        if (roomId.endsWith('-vip1')) tier = 'vip1';
        else if (roomId.endsWith('-vip2')) tier = 'vip2';
        else if (roomId.endsWith('-vip3')) tier = 'vip3';
        else if (roomId.endsWith('-vip4')) tier = 'vip4';
        
        manifest[roomId] = `data/${filename}`;
        dataImports[roomId] = {
          id: roomId,
          nameEn: names.nameEn,
          nameVi: names.nameVi,
          tier,
          hasData: true
        };
        
        console.log(`‚úì Registered: ${roomId} ‚Üí data/${filename}`);
      } catch (error) {
        console.error(`Error processing ${filename}:`, error);
      }
    }
  } catch (error) {
    console.error('Error scanning directory:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    throw new Error(`Failed to scan data directory: ${message}`);
  }
  
  return { manifest, dataImports };
}

function generateManifestContent(manifest: Record<string, string>): string {
  return `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: regenerate-registry edge function
 */
export const PUBLIC_ROOM_MANIFEST: Record<string, string> = ${JSON.stringify(manifest, null, 2)};

/**
 * Get all unique room base names (without tier suffix)
 */
export function getRoomBaseNames(): string[] {
  const baseNames = new Set<string>();
  
  for (const roomId of Object.keys(PUBLIC_ROOM_MANIFEST)) {
    const baseName = roomId.replace(/-(free|vip1|vip2|vip3|vip4)$/, '');
    baseNames.add(baseName);
  }
  
  return Array.from(baseNames).sort();
}

/**
 * Get all tiers available for a room base name
 */
export function getAvailableTiers(roomBaseName: string): string[] {
  const tiers: string[] = [];
  
  for (const tier of ['free', 'vip1', 'vip2', 'vip3', 'vip4']) {
    const roomId = \`\${roomBaseName}-\${tier}\`;
    if (PUBLIC_ROOM_MANIFEST[roomId]) {
      tiers.push(tier);
    }
  }
  
  return tiers;
}
`;
}

function generateDataImportsContent(dataImports: Record<string, RoomData>): string {
  const entries = Object.entries(dataImports).map(([key, value]) => {
    return `  "${key}": ${JSON.stringify(value, null, 4).replace(/\n/g, '\n  ')}`;
  }).join(',\n');
  
  return `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: regenerate-registry edge function
 */
import { RoomData } from "@/lib/roomData";

export const roomDataMap: Record<string, RoomData> = {
${entries}
};
`;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    console.log('üîç Scanning for room JSON files...');
    const { manifest, dataImports } = await scanRoomFiles();
    
    console.log(`üì¶ Found ${Object.keys(manifest).length} room files`);
    
    const manifestContent = generateManifestContent(manifest);
    const dataImportsContent = generateDataImportsContent(dataImports);
    
    await Deno.writeTextFile('./src/lib/roomManifest.ts', manifestContent);
    await Deno.writeTextFile('./src/lib/roomDataImports.ts', dataImportsContent);
    
    console.log('‚úÖ Registry files updated successfully');
    
    return new Response(
      JSON.stringify({
        success: true,
        roomsProcessed: Object.keys(manifest).length,
        rooms: Object.keys(manifest)
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Error regenerating registry:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: message
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
