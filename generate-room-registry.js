/**
 * Auto-generate room registry from all JSON files in public/data
 * Run with: node scripts/generate-room-registry.js
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Project root (one level up from scripts/)
const projectRoot = path.resolve(__dirname, "..");
const publicDataDir = path.join(projectRoot, "public", "data");

/**
 * Convert filename to roomId (kebab-case)
 * english_writing_free.json ‚Üí english-writing-free
 */
function filenameToRoomId(filename) {
  const base = filename.replace(/\.json$/i, "");

  return base
    .toLowerCase()
    .replace(/[_\s]+/g, "-")
    .replace(
      /-(free|vip1|vip2|vip3|vip3[-_]ii|vip4|vip5|vip6|vip9|kidslevel3)$/i,
      (m) => m.toLowerCase()
    );
}

/**
 * Extract display names from JSON (best-effort)
 */
function extractNames(jsonPath) {
  try {
    const content = JSON.parse(fs.readFileSync(jsonPath, "utf8"));

    const nameEn =
      content.name ||
      content.nameEn ||
      content.title?.en ||
      "Unknown Room";

    const nameVi =
      content.name_vi ||
      content.nameVi ||
      content.title?.vi ||
      nameEn;

    return { nameEn, nameVi };
  } catch (err) {
    console.warn(`‚ö†Ô∏è  Could not parse ${jsonPath}: ${err.message}`);
    return null;
  }
}

/**
 * Scan public/data for JSON room files
 */
function scanRoomFiles() {
  if (!fs.existsSync(publicDataDir)) {
    throw new Error(`public/data directory not found at ${publicDataDir}`);
  }

  const files = fs.readdirSync(publicDataDir);
  const jsonFiles = files.filter(
    (f) => f.endsWith(".json") && !f.startsWith(".")
  );

  const manifest = {};
  const dataImports = {};

  for (const filename of jsonFiles) {
    const roomId = filenameToRoomId(filename);
    const jsonPath = path.join(publicDataDir, filename);
    const names = extractNames(jsonPath);

    if (!names) continue;

    // Determine tier
    let tier = "free";
    if (roomId.endsWith("-vip3-ii")) tier = "vip3_ii";
    else if (roomId.endsWith("-vip9")) tier = "vip9";
    else if (roomId.endsWith("-vip6")) tier = "vip6";
    else if (roomId.endsWith("-vip5")) tier = "vip5";
    else if (roomId.endsWith("-vip4")) tier = "vip4";
    else if (roomId.endsWith("-vip3")) tier = "vip3";
    else if (roomId.endsWith("-vip2")) tier = "vip2";
    else if (roomId.endsWith("-vip1")) tier = "vip1";
    else if (roomId.endsWith("-kidslevel3")) tier = "kidslevel3";

    /**
     * üîë CRITICAL FIX
     * Manifest values MUST include "data/"
     * Runtime fetches from /data/*.json
     */
    manifest[roomId] = `data/${filename}`;

    // Legacy support (will be removed later)
    dataImports[roomId] = {
      id: roomId,
      nameEn: names.nameEn,
      nameVi: names.nameVi,
      tier,
      hasData: true,
    };
  }

  return { manifest, dataImports };
}

/**
 * Generate src/lib/roomManifest.ts
 */
function generateManifest(manifest) {
  const content = `/**
 * AUTO-GENERATED ‚Äî DO NOT EDIT
 * Generated by: scripts/generate-room-registry.js
 */

export const PUBLIC_ROOM_MANIFEST: Record<string, string> = ${JSON.stringify(
    manifest,
    null,
    2
  )};

export function getRoomBaseNames(): string[] {
  const baseNames = new Set<string>();

  for (const roomId of Object.keys(PUBLIC_ROOM_MANIFEST)) {
    const baseName = roomId.replace(
      /-(free|vip1|vip2|vip3|vip3[-_]ii|vip4|vip5|vip6|vip9|kidslevel3)$/,
      ""
    );
    baseNames.add(baseName);
  }

  return Array.from(baseNames).sort();
}

export function getAvailableTiers(roomBaseName: string): string[] {
  const tiers: string[] = [];

  for (const tier of [
    "free",
    "vip1",
    "vip2",
    "vip3",
    "vip3_ii",
    "vip4",
    "vip5",
    "vip6",
    "vip9",
    "kidslevel3",
  ]) {
    const roomId = \`\${roomBaseName}-\${tier}\`;
    if (PUBLIC_ROOM_MANIFEST[roomId]) {
      tiers.push(tier);
    }
  }

  return tiers;
}
`;

  const outputPath = path.join(
    projectRoot,
    "src",
    "lib",
    "roomManifest.ts"
  );

  fs.writeFileSync(outputPath, content, "utf8");
  console.log(
    `‚úÖ Generated roomManifest.ts (${Object.keys(manifest).length} rooms)`
  );
}

/**
 * Generate legacy roomDataImports.ts (to be removed later)
 */
function generateDataImports(dataImports) {
  const entries = Object.entries(dataImports)
    .map(
      ([key, value]) =>
        `  "${key}": ${JSON.stringify(value, null, 4).replace(
          /\n/g,
          "\n  "
        )}`
    )
    .join(",\n");

  const content = `/**
 * AUTO-GENERATED ‚Äî DO NOT EDIT
 * Generated by: scripts/generate-room-registry.js
 */

import { RoomData } from "@/lib/roomData";

export const roomDataMap: Record<string, RoomData> = {
${entries}
};
`;

  const outputPath = path.join(
    projectRoot,
    "src",
    "lib",
    "roomDataImports.ts"
  );

  fs.writeFileSync(outputPath, content, "utf8");
  console.log(
    `‚úÖ Generated roomDataImports.ts (${Object.keys(dataImports).length} rooms)`
  );
}

/**
 * Main
 */
try {
  console.log("üîç Scanning public/data for room JSON files...");
  const { manifest, dataImports } = scanRoomFiles();

  console.log(`üì¶ Found ${Object.keys(manifest).length} rooms`);

  generateManifest(manifest);
  generateDataImports(dataImports);

  console.log("‚ú® Room registry generation complete");
} catch (err) {
  console.error("‚ùå Failed to generate room registry:", err);
  process.exit(1);
}
