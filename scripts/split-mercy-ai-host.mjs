import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const SRC = path.join(ROOT, "src/components/guide/MercyAIHost.tsx");
const OUT_DIR = path.join(ROOT, "src/components/guide/host");

function die(msg) {
  console.error("[split-mercy-ai-host] " + msg);
  process.exit(1);
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function backupFile(filePath) {
  const bak = filePath + ".BAK." + new Date().toISOString().replace(/[:.]/g, "-");
  fs.copyFileSync(filePath, bak);
  return bak;
}

function writeIfChanged(filePath, next) {
  const prev = fs.existsSync(filePath) ? fs.readFileSync(filePath, "utf8") : "";
  if (prev === next) return false;
  fs.writeFileSync(filePath, next);
  return true;
}

// Extract a block by regex capture (group 0 is full match).
function extractOne(src, re, label) {
  const m = src.match(re);
  if (!m) return { found: false, src, block: "" };
  const block = m[0];
  const nextSrc = src.replace(block, "");
  return { found: true, src: nextSrc, block };
}

// Insert import lines after the last import in file.
function insertImports(src, lines) {
  const importRe = /^import .*?;\s*$/gm;
  let last = -1;
  let m;
  while ((m = importRe.exec(src))) last = m.index + m[0].length;
  if (last === -1) {
    // No imports, prepend.
    return lines.join("\n") + "\n\n" + src;
  }
  return src.slice(0, last) + "\n" + lines.join("\n") + src.slice(last);
}

function dedupeImportLines(lines) {
  const seen = new Set();
  const out = [];
  for (const l of lines) {
    const k = l.trim();
    if (!k) continue;
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(l);
  }
  return out;
}

function normalizeNewlines(s) {
  return s.replace(/\r\n/g, "\n");
}

function stripDoubleBlankLines(s) {
  return s.replace(/\n{3,}/g, "\n\n");
}

function main() {
  if (!fs.existsSync(SRC)) die("Missing file: " + SRC);

  let code = normalizeNewlines(fs.readFileSync(SRC, "utf8"));

  ensureDir(OUT_DIR);

  const bak = backupFile(SRC);
  console.log("[split-mercy-ai-host] backup:", bak);

  // --- 1) Extract QuickAction type (common patterns) ---
  // Try a few patterns: `type QuickAction = { ... };` or `export type QuickAction ...`
  // Stop at the next `type`/`interface`/`const`/`function` at column 0 if possible.
  const quickActionRe =
    /^(export\s+)?type\s+QuickAction\s*=\s*\{[\s\S]*?\};\s*\n/m;

  let qa = extractOne(code, quickActionRe, "QuickAction type");
  code = qa.src;

  // --- 2) Extract buildQuickActions function/const ---
  // Support: `function buildQuickActions(...) { ... }` OR `const buildQuickActions = (...) => { ... };`
  const buildFnRe =
    /^function\s+buildQuickActions\s*\([\s\S]*?\n\}\s*\n/m;
  const buildConstRe =
    /^const\s+buildQuickActions\s*=\s*[\s\S]*?\n\};\s*\n/m;

  let bq = extractOne(code, buildFnRe, "buildQuickActions()");
  if (!bq.found) bq = extractOne(code, buildConstRe, "buildQuickActions const");
  code = bq.src;

  // --- 3) Extract Host UI components ---
  // Prefer extracting BOTH HostStatusChip and HostQuickActions when present.
  const hostStatusFnRe =
    /^function\s+HostStatusChip\s*\([\s\S]*?\n\}\s*\n/m;
  const hostStatusConstRe =
    /^const\s+HostStatusChip\s*=\s*[\s\S]*?\n\};\s*\n/m;

  const hostQuickFnRe =
    /^function\s+HostQuickActions\s*\([\s\S]*?\n\}\s*\n/m;
  const hostQuickConstRe =
    /^const\s+HostQuickActions\s*=\s*[\s\S]*?\n\};\s*\n/m;

  let hs = extractOne(code, hostStatusFnRe, "HostStatusChip()");
  if (!hs.found) hs = extractOne(code, hostStatusConstRe, "HostStatusChip const");
  code = hs.src;

  let hq = extractOne(code, hostQuickFnRe, "HostQuickActions()");
  if (!hq.found) hq = extractOne(code, hostQuickConstRe, "HostQuickActions const");
  code = hq.src;

  // Safety: if we found nothing, abort (we wonâ€™t destroy file structure).
  const foundAny = qa.found || bq.found || hs.found || hq.found;
  if (!foundAny) {
    // Restore from backup
    fs.copyFileSync(bak, SRC);
    die("Could not find expected blocks (QuickAction/buildQuickActions/HostUI). No changes made.");
  }

  // --- Write quickActions.ts if we found something relevant ---
  if (qa.found || bq.found) {
    const parts = [];
    parts.push(`// AUTO-GENERATED by scripts/split-mercy-ai-host.mjs`);
    parts.push(`// Source: src/components/guide/MercyAIHost.tsx`);
    parts.push("");
    // If QuickAction type existed but was not exported, export it.
    if (qa.found) {
      let t = qa.block;
      if (!/^export\s+type\s+QuickAction/m.test(t)) {
        t = t.replace(/^type\s+QuickAction/m, "export type QuickAction");
      }
      parts.push(t.trimEnd());
      parts.push("");
    } else {
      // Provide minimal type to keep buildQuickActions typed if it references QuickAction.
      parts.push(`export type QuickAction = {`);
      parts.push(`  id: string;`);
      parts.push(`  label: string;`);
      parts.push(`  description?: string;`);
      parts.push(`  onClick: () => void;`);
      parts.push(`};`);
      parts.push("");
    }

    if (bq.found) {
      let fn = bq.block.trimEnd();
      // Ensure export
      if (/^function\s+buildQuickActions/m.test(fn)) {
        fn = fn.replace(/^function\s+buildQuickActions/m, "export function buildQuickActions");
      } else if (/^const\s+buildQuickActions/m.test(fn)) {
        fn = fn.replace(/^const\s+buildQuickActions/m, "export const buildQuickActions");
      }
      parts.push(fn);
      parts.push("");
    } else {
      // Provide stub so MercyAIHost can import safely
      parts.push(`export function buildQuickActions() {`);
      parts.push(`  return [] as QuickAction[];`);
      parts.push(`}`);
      parts.push("");
    }

    const quickActionsPath = path.join(OUT_DIR, "quickActions.ts");
    writeIfChanged(quickActionsPath, parts.join("\n"));
    console.log("[split-mercy-ai-host] wrote:", quickActionsPath);
  }

  // --- Write HostUI.tsx if we found UI parts ---
  if (hs.found || hq.found) {
    const parts = [];
    parts.push(`// AUTO-GENERATED by scripts/split-mercy-ai-host.mjs`);
    parts.push(`// Source: src/components/guide/MercyAIHost.tsx`);
    parts.push("");
    parts.push(`import React from "react";`);
    parts.push("");

    if (hs.found) {
      let c = hs.block.trimEnd();
      // Ensure export
      if (/^function\s+HostStatusChip/m.test(c)) c = c.replace(/^function\s+HostStatusChip/m, "export function HostStatusChip");
      if (/^const\s+HostStatusChip/m.test(c)) c = c.replace(/^const\s+HostStatusChip/m, "export const HostStatusChip");
      parts.push(c);
      parts.push("");
    } else {
      parts.push(`export function HostStatusChip() { return null; }`);
      parts.push("");
    }

    if (hq.found) {
      let c = hq.block.trimEnd();
      if (/^function\s+HostQuickActions/m.test(c)) c = c.replace(/^function\s+HostQuickActions/m, "export function HostQuickActions");
      if (/^const\s+HostQuickActions/m.test(c)) c = c.replace(/^const\s+HostQuickActions/m, "export const HostQuickActions");
      parts.push(c);
      parts.push("");
    } else {
      parts.push(`export function HostQuickActions() { return null; }`);
      parts.push("");
    }

    const hostUIPath = path.join(OUT_DIR, "HostUI.tsx");
    writeIfChanged(hostUIPath, parts.join("\n"));
    console.log("[split-mercy-ai-host] wrote:", hostUIPath);
  }

  // --- Update MercyAIHost.tsx: add imports if needed, and strip now-empty excess whitespace ---
  const importsToAdd = [];

  if ((qa.found || bq.found) && !code.includes('from "./host/quickActions"')) {
    importsToAdd.push(`import { buildQuickActions } from "./host/quickActions";`);
  }
  if ((hs.found || hq.found) && !code.includes('from "./host/HostUI"')) {
    importsToAdd.push(`import { HostStatusChip, HostQuickActions } from "./host/HostUI";`);
  }

  if (importsToAdd.length) {
    code = insertImports(code, dedupeImportLines(importsToAdd));
  }

  code = stripDoubleBlankLines(code);

  // Final write
  fs.writeFileSync(SRC, code);
  console.log("[split-mercy-ai-host] updated:", SRC);

  console.log("[split-mercy-ai-host] done.");
  console.log("[split-mercy-ai-host] if anything looks wrong: git checkout -- src/components/guide/MercyAIHost.tsx");
}

main();
