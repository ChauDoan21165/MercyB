/**
 * Remove non-existent rooms from manifest
 * Run with: node scripts/clean-manifest.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

// Check if file exists
function fileExists(filePath) {
  try {
    return fs.existsSync(filePath);
  } catch {
    return false;
  }
}

// Get all existing JSON files
function getAllExistingFiles() {
  const existing = new Set();
  const tiers = ['free', 'vip1', 'vip2', 'vip3'];
  
  for (const tier of tiers) {
    const tierDir = path.join(projectRoot, 'public', 'data', tier);
    if (!fs.existsSync(tierDir)) continue;
    
    const files = fs.readdirSync(tierDir);
    files.filter(f => f.endsWith('.json')).forEach(f => {
      existing.add(`data/${tier}/${f}`);
    });
  }
  
  return existing;
}

// Extract names from JSON
function extractNames(jsonPath) {
  try {
    const content = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
    const nameEn = content.name || content.nameEn || content.title?.en || 'Unknown Room';
    const nameVi = content.name_vi || content.nameVi || content.title?.vi || nameEn;
    return { nameEn, nameVi };
  } catch (err) {
    console.warn(`Warning: Could not parse ${jsonPath}`);
    return null;
  }
}

// Convert filename to room ID
function filenameToRoomId(filename) {
  const base = filename.replace(/\.json$/i, '');
  return base
    .toLowerCase()
    .replace(/[_\s]+/g, '-')
    .replace(/-(free|vip1|vip2|vip3)$/i, (match) => match.toLowerCase());
}

// Generate clean manifest
function generateCleanManifest() {
  console.log('üîç Scanning existing files...\n');
  
  const existingFiles = getAllExistingFiles();
  const manifest = {};
  const dataImports = {};
  
  console.log(`Found ${existingFiles.size} files\n`);
  
  for (const filePath of existingFiles) {
    const filename = path.basename(filePath);
    const roomId = filenameToRoomId(filename);
    const fullPath = path.join(projectRoot, 'public', filePath);
    const names = extractNames(fullPath);
    
    if (!names) continue;
    
    // Extract tier
    const tierMatch = filePath.match(/data\/(free|vip1|vip2|vip3)\//);
    const tier = tierMatch ? tierMatch[1] : 'free';
    
    manifest[roomId] = filePath;
    dataImports[roomId] = {
      id: roomId,
      nameEn: names.nameEn,
      nameVi: names.nameVi,
      tier,
      hasData: true
    };
    
    console.log(`‚úì ${roomId} ‚Üí ${filePath}`);
  }
  
  // Write manifest
  const manifestContent = `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/clean-manifest.js
 * Run: node scripts/clean-manifest.js
 */
export const PUBLIC_ROOM_MANIFEST: Record<string, string> = ${JSON.stringify(manifest, null, 2)};

/**
 * Get all unique room base names (without tier suffix)
 */
export function getRoomBaseNames(): string[] {
  const baseNames = new Set<string>();
  
  for (const roomId of Object.keys(PUBLIC_ROOM_MANIFEST)) {
    const baseName = roomId.replace(/-(free|vip1|vip2|vip3)$/, '');
    baseNames.add(baseName);
  }
  
  return Array.from(baseNames).sort();
}

/**
 * Get all tiers available for a room base name
 */
export function getAvailableTiers(roomBaseName: string): string[] {
  const tiers: string[] = [];
  
  for (const tier of ['free', 'vip1', 'vip2', 'vip3']) {
    const roomId = \`\${roomBaseName}-\${tier}\`;
    if (PUBLIC_ROOM_MANIFEST[roomId]) {
      tiers.push(tier);
    }
  }
  
  return tiers;
}
`;
  
  const manifestPath = path.join(projectRoot, 'src', 'lib', 'roomManifest.ts');
  fs.writeFileSync(manifestPath, manifestContent, 'utf8');
  
  // Write dataImports
  const entries = Object.entries(dataImports).map(([key, value]) => {
    return `  "${key}": ${JSON.stringify(value, null, 4).replace(/\n/g, '\n  ')}`;
  }).join(',\n');
  
  const importsContent = `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/clean-manifest.js
 */
import { RoomData } from "@/lib/roomData";

export const roomDataMap: Record<string, RoomData> = {
${entries}
};
`;
  
  const importsPath = path.join(projectRoot, 'src', 'lib', 'roomDataImports.ts');
  fs.writeFileSync(importsPath, importsContent, 'utf8');
  
  console.log(`\n‚úÖ Generated manifest with ${Object.keys(manifest).length} rooms`);
  console.log(`‚úÖ Generated dataImports with ${Object.keys(dataImports).length} rooms`);
}

try {
  generateCleanManifest();
  console.log('\n‚ú® Clean manifest generation complete!');
} catch (err) {
  console.error('‚ùå Error:', err);
  process.exit(1);
}
