/**
 * Auto-generate room registry from all JSON files in public directory
 * Run with: node scripts/generate-room-registry.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get project root (one level up from scripts/)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get project root (one level up from scripts/)
const projectRoot = path.resolve(__dirname, '..');
const publicDir = path.join(projectRoot, 'public');
const ROOM_FILE_REGEX = /(free|vip1|vip2|vip3|vip4)\.json$/i;

// Helper to convert filename to room ID (kebab-case with tier)
function filenameToRoomId(filename) {
  // Remove .json extension
  const base = filename.replace(/\.json$/i, '');
  
  // Convert to kebab-case and normalize tier suffix
  return base
    .toLowerCase()
    .replace(/[_\s]+/g, '-') // underscores and spaces to hyphens
    .replace(/-(free|vip1|vip2|vip3|vip4)$/i, (match) => match.toLowerCase()); // normalize tier
}

// Helper to extract display names from JSON
function extractNames(jsonPath, filename) {
  try {
    const content = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
    
    // Prioritize title field for display names (proper structure)
    let nameEn = content.title?.en || content.nameEn || null;
    let nameVi = content.title?.vi || content.nameVi || content.name_vi || null;
    
    // If name field exists and doesn't look like a filename, use it as fallback
    if (!nameEn && content.name && !content.name.includes('.json')) {
      nameEn = content.name;
    }
    
    // If still no name found, extract from filename
    if (!nameEn) {
      nameEn = filename
        .replace(/\.(json)$/i, '')
        .replace(/[_-](free|vip1|vip2|vip3|vip4)$/i, '')
        .replace(/[_-]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }
    
    nameVi = nameVi || nameEn;
    
    return { nameEn, nameVi };
  } catch (err) {
    console.warn(`Warning: Could not parse ${jsonPath}:`, err.message);
    return null;
  }
}

// Scan public/data directory for JSON files (flat structure) with error recovery
function scanRoomFiles() {
  const dataDir = path.join(publicDir, 'data');
  
  if (!fs.existsSync(dataDir)) {
    console.error(`Error: Data directory not found: ${dataDir}`);
    console.log('Creating data directory...');
    fs.mkdirSync(dataDir, { recursive: true });
    return { manifest: {}, dataImports: {} };
  }
  
  const files = fs.readdirSync(dataDir);
  const roomFiles = files.filter(f => f.endsWith('.json') && !f.startsWith('.') && ROOM_FILE_REGEX.test(f));
  
  const manifest = {};
  const dataImports = {};
  
  console.log(`Found ${roomFiles.length} room files to process`);
  
  for (const filename of roomFiles) {
    try {
      const roomId = filenameToRoomId(filename);
      const jsonPath = path.join(dataDir, filename);
      const names = extractNames(jsonPath, filename);
      
      if (!names) {
        console.warn(`‚ö†Ô∏è  Skipping ${filename}: Could not extract names`);
        continue;
      }
      
      // Extract tier from filename
      let tier = 'free';
      if (roomId.endsWith('-vip1')) tier = 'vip1';
      else if (roomId.endsWith('-vip2')) tier = 'vip2';
      else if (roomId.endsWith('-vip3')) tier = 'vip3';
      else if (roomId.endsWith('-vip4')) tier = 'vip4';
      
      // Add to manifest with data/ prefix
      manifest[roomId] = `data/${filename}`;
      
      // Add to dataImports
      dataImports[roomId] = {
        id: roomId,
        nameEn: names.nameEn,
        nameVi: names.nameVi,
        tier,
        hasData: true
      };
      
      console.log(`‚úì Registered: ${roomId} ‚Üí data/${filename}`);
    } catch (error) {
      console.error(`‚úó Error processing ${filename}:`, error.message);
      // Continue processing other files instead of failing
    }
  }
  
  return { manifest, dataImports };
}

// Generate manifest file
function generateManifest(manifest) {
  const content = `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/generate-room-registry.js
 * Run: node scripts/generate-room-registry.js
 */
export const PUBLIC_ROOM_MANIFEST: Record<string, string> = ${JSON.stringify(manifest, null, 2)};

/**
 * Get all unique room base names (without tier suffix)
 */
export function getRoomBaseNames(): string[] {
  const baseNames = new Set<string>();
  
  for (const roomId of Object.keys(PUBLIC_ROOM_MANIFEST)) {
    const baseName = roomId.replace(/-(free|vip1|vip2|vip3|vip4)$/, '');
    baseNames.add(baseName);
  }
  
  return Array.from(baseNames).sort();
}

/**
 * Get all tiers available for a room base name
 */
export function getAvailableTiers(roomBaseName: string): string[] {
  const tiers: string[] = [];
  
  for (const tier of ['free', 'vip1', 'vip2', 'vip3', 'vip4']) {
    const roomId = \`\${roomBaseName}-\${tier}\`;
    if (PUBLIC_ROOM_MANIFEST[roomId]) {
      tiers.push(tier);
    }
  }
  
  return tiers;
}
`;
  
  const manifestPath = path.join(projectRoot, 'src', 'lib', 'roomManifest.ts');
  fs.writeFileSync(manifestPath, content, 'utf8');
  console.log(`‚úÖ Generated roomManifest.ts with ${Object.keys(manifest).length} rooms`);
}

// Generate dataImports file
function generateDataImports(dataImports) {
  const entries = Object.entries(dataImports).map(([key, value]) => {
    return `  "${key}": ${JSON.stringify(value, null, 4).replace(/\n/g, '\n  ')}`;
  }).join(',\n');
  
  const content = `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/generate-room-registry.js
 * Run: node scripts/generate-room-registry.js
 */
import { RoomData } from "@/lib/roomData";

export const roomDataMap: Record<string, RoomData> = {
${entries}
};
`;
  
  const importsPath = path.join(projectRoot, 'src', 'lib', 'roomDataImports.ts');
  fs.writeFileSync(importsPath, content, 'utf8');
  console.log(`‚úÖ Generated roomDataImports.ts with ${Object.keys(dataImports).length} rooms`);
}

// Main execution
try {
  console.log('üîç Scanning for room JSON files...');
  const { manifest, dataImports } = scanRoomFiles();
  
  console.log(`üì¶ Found ${Object.keys(manifest).length} room files`);
  
  generateManifest(manifest);
  generateDataImports(dataImports);
  
  console.log('‚ú® Room registry generation complete!');
} catch (err) {
  console.error('‚ùå Error generating room registry:', err);
  process.exit(1);
}
