/**
 * Auto-generate room registry from ALL JSON files in public/data
 *
 * GOAL (strategic):
 * - NEVER reject rooms (register first, warn later)
 * - ONE canonical ID format: snake_case (underscores)
 * - Manifest paths must work in production fetch: "/data/<file>.json"
 *
 * Generates:
 * A) src/lib/roomManifest.ts        -> PUBLIC_ROOM_MANIFEST: id -> "/data/file.json"
 * B) src/lib/roomDataImports.ts     -> roomDataMap: id -> { id, nameEn, nameVi, tier, hasData }
 * C) src/lib/roomList.ts            -> ROOM_IDS: string[] (sorted)
 *
 * Run: node scripts/generate-room-registry.js
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");

const dataDir = path.join(projectRoot, "public", "data");

// -------- Canonicalization (ONE TIME) --------
function canonicalIdFromFilename(filename) {
  const base = filename.replace(/\.json$/i, "");
  return base
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_")
    .replace(/-+/g, "_");
}

function inferTierFromId(id) {
  // keep flexible; do NOT reject unknown tiers
  const m =
    id.match(/_(free|vip\d+|vip3_ii|kidslevel[123])$/i) ||
    id.match(/_(vip\d+_vol\d+)$/i); // optional patterns
  return m ? m[1].toLowerCase() : "free";
}

function safeReadJson(jsonPath) {
  try {
    const raw = fs.readFileSync(jsonPath, "utf8");
    return JSON.parse(raw);
  } catch (e) {
    return { __parse_error: String(e?.message || e) };
  }
}

function titleCaseFromId(id) {
  return id
    .replace(/_(free|vip\d+|vip3_ii|kidslevel[123])$/i, "")
    .split(/[_-]+/)
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

function pickNameEn(obj, fallback) {
  return (
    obj?.name ||
    obj?.nameEn ||
    obj?.title_en ||
    obj?.titleEn ||
    obj?.description?.en ||
    (typeof obj?.title === "string" ? obj.title : obj?.title?.en) ||
    fallback
  );
}

function pickNameVi(obj, fallback) {
  return (
    obj?.name_vi ||
    obj?.nameVi ||
    obj?.title_vi ||
    obj?.titleVi ||
    obj?.description?.vi ||
    (typeof obj?.title === "object" ? obj?.title?.vi : null) ||
    fallback
  );
}

// -------- Scan & generate --------
function scanAllRooms() {
  if (!fs.existsSync(dataDir)) {
    throw new Error(`Missing folder: ${dataDir}`);
  }

  const files = fs
    .readdirSync(dataDir)
    .filter((f) => f.toLowerCase().endsWith(".json") && !f.startsWith("."))
    .sort((a, b) => a.localeCompare(b));

  const manifest = {};
  const roomDataMap = {};
  const warnings = [];

  let registered = 0;

  for (const filename of files) {
    const jsonPath = path.join(dataDir, filename);
    const json = safeReadJson(jsonPath);

    const canonicalId = canonicalIdFromFilename(filename);

    // Path MUST be web-fetchable in prod: "/data/<filename>"
    // (because public/ is served at site root)
    manifest[canonicalId] = `/data/${filename}`;

    const tier = inferTierFromId(canonicalId);

    const fallbackTitle = titleCaseFromId(canonicalId);
    const nameEn = pickNameEn(json, fallbackTitle);
    const nameVi = pickNameVi(json, nameEn);

    roomDataMap[canonicalId] = {
      id: canonicalId,
      nameEn: String(nameEn || fallbackTitle),
      nameVi: String(nameVi || nameEn || fallbackTitle),
      tier,
      hasData: true,
    };

    // WARN ONLY (never reject)
    if (json?.__parse_error) {
      warnings.push(`PARSE_ERROR ${filename}: ${json.__parse_error}`);
    } else {
      const jsonId = String(json?.id || "");
      if (jsonId && jsonId !== canonicalId) {
        warnings.push(`ID_MISMATCH ${filename}: json.id="${jsonId}" != "${canonicalId}"`);
      }
      if (!Array.isArray(json?.entries)) {
        warnings.push(`NO_ENTRIES_ARRAY ${filename}: entries missing or not array`);
      }
    }

    registered++;
  }

  return { filesCount: files.length, registered, warnings, manifest, roomDataMap };
}

function writeFile(filepath, content) {
  fs.mkdirSync(path.dirname(filepath), { recursive: true });
  fs.writeFileSync(filepath, content, "utf8");
}

// -------- Outputs --------
function generateRoomManifestTs(manifest) {
  return `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/generate-room-registry.js
 * Run: node scripts/generate-room-registry.js
 */
export const PUBLIC_ROOM_MANIFEST: Record<string, string> = ${JSON.stringify(manifest, null, 2)};

/** Get all unique room base names (without tier suffix) */
export function getRoomBaseNames(): string[] {
  const baseNames = new Set<string>();
  for (const roomId of Object.keys(PUBLIC_ROOM_MANIFEST)) {
    const baseName = roomId.replace(/_(free|vip\\d+|vip3_ii|kidslevel[123])$/, "");
    baseNames.add(baseName);
  }
  return Array.from(baseNames).sort();
}

/** Get all tiers available for a room base name */
export function getAvailableTiers(roomBaseName: string): string[] {
  const tiers: string[] = [];
  for (const tier of ["free","vip1","vip2","vip3","vip3_ii","vip4","vip5","vip6","vip7","vip8","vip9","kidslevel1","kidslevel2","kidslevel3"]) {
    const roomId = \`\${roomBaseName}_\${tier}\`;
    if (PUBLIC_ROOM_MANIFEST[roomId]) tiers.push(tier);
  }
  return tiers;
}
`;
}

function generateRoomDataImportsTs(roomDataMap) {
  const entries = Object.entries(roomDataMap)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([k, v]) => `  "${k}": ${JSON.stringify(v, null, 2).replace(/\n/g, "\n  ")}`)
    .join(",\n");

  return `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/generate-room-registry.js
 * Run: node scripts/generate-room-registry.js
 */
export type RoomData = {
  id: string;
  nameEn: string;
  nameVi: string;
  tier: string;
  hasData: boolean;
};

export const roomDataMap: Record<string, RoomData> = {
${entries}
};
`;
}

function generateRoomListTs(roomDataMap) {
  const ids = Object.keys(roomDataMap).sort();
  return `/**
 * AUTO-GENERATED: Do not edit manually
 * Generated by: scripts/generate-room-registry.js
 * Run: node scripts/generate-room-registry.js
 */
export const ROOM_IDS: string[] = ${JSON.stringify(ids, null, 2)};
`;
}

// -------- Main --------
try {
  const { filesCount, registered, warnings, manifest, roomDataMap } = scanAllRooms();

  console.log(`üì¶ Total JSON files: ${filesCount}`);
  console.log(`üìå Registered rooms: ${registered}`);
  console.log(`‚ö†Ô∏è  Warnings (non-fatal): ${warnings.length}`);

  const outManifest = path.join(projectRoot, "src", "lib", "roomManifest.ts");
  const outImports = path.join(projectRoot, "src", "lib", "roomDataImports.ts");
  const outList = path.join(projectRoot, "src", "lib", "roomList.ts");

  writeFile(outManifest, generateRoomManifestTs(manifest));
  writeFile(outImports, generateRoomDataImportsTs(roomDataMap));
  writeFile(outList, generateRoomListTs(roomDataMap));

  console.log(`‚úÖ Wrote: ${path.relative(projectRoot, outManifest)}`);
  console.log(`‚úÖ Wrote: ${path.relative(projectRoot, outImports)}`);
  console.log(`‚úÖ Wrote: ${path.relative(projectRoot, outList)}`);
  console.log("‚ú® Done.");
} catch (err) {
  console.error("‚ùå Generator failed:", err?.message || err);
  process.exit(1);
}
